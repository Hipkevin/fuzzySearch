# 算法分析与设计期末报告——基于Faiss和Levenshtein距离的无监督文本匹配

## 解决方案

本案例的问题有两个难点：一是数据量大，O(n)级别的全表扫描时间成本太大；二是需要匹配的两个数据源具有较大的模糊性。针对这两个难点，本案例使用基于Faiss引擎和Levenshtein距离文本匹配算法，将时间复杂度控制在O(logn)级别。

Levenshtein距离也称编辑距离，在计算文本的相似性时，经常会用到编辑距离。是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。通常来说，编辑距离越小，两个文本的相似性越大。在公司名称匹配的场景下，编辑距离会更加适合用来度量两个名称的相似度。如上文中“万科文化传播有限责任公司”的例子，那么这个字符串到“北京万科文化传播有限责任公司”的编辑距离为2，到另一个字符串的编辑距离为5。

Faiss（Facebook AI Similarity Search）是一个用于高效相似性搜索和密集向量聚类的库。Faiss包含多种相似性搜索方法。它假设检索样本表示为向量并包含整数索引，并且可以将向量与 L2距离或点积进行比较。大多数方法，如基于二进制向量和紧凑量化代码的方法，只使用向量的压缩表示，不需要保留原始向量，这通常是以降低搜索精度为代价的。另外，Faiss支持GPU并行加速搜索，在各种多模态的智能搜索场景有广泛的应用。

由于计算编辑距离的算法需要计算两个字符串的笛卡儿积，复杂度为O(m\*n)。这个操作在全表扫描下的时间成本是无法被接受的，所以本案例加入Faiss搜索作为整个匹配算法的召回层，在召回的TopK中选择编辑距离最小的标记为匹配，距离过大的召回则直接记为不匹配。另外，原始的Levenshtein距离算法的空间复杂度为O(m\*n)，本案例通过压缩DP矩阵对算法进行优化，使其空间复杂度为O(n)，n为较短的字符串。
